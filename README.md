# CS300-project
# CS300 Project Reflection

## Problem I Was Solving
In these projects, I worked on analyzing and using data structures. For Project One, I had to look at the run-time and memory use for different data structures and explain how they compared. For Project Two, I created code that sorts and prints out a list of Computer Science courses in alphanumeric order. The main problem I was solving was understanding which data structures work best in different situations and showing that through both analysis and working code.

## My Approach
I approached the problem by breaking it down into smaller steps. First, I reviewed how each data structure worked, such as arrays, vectors, and linked lists, and noted their advantages and disadvantages. Then, I focused on the sorting part by writing code that could handle the list of courses and arrange them correctly. Data structures are important because they affect how fast programs run and how much memory they use, so I tried to connect what I learned about them to my solution.

## Overcoming Roadblocks
One challenge I had was making sure my code actually printed the courses in the right order. At first, I had issues with indexing and logic errors, but I fixed those by testing with smaller inputs and checking the output carefully. I also went back to my notes and examples from class whenever I got stuck.

## What I Learned About Designing Software
This project helped me see that designing software isn’t just about making it work once—it’s about thinking ahead to how it will be used and how efficient it is. I realized that choosing the right data structure can make a big difference in performance. It also made me more confident in analyzing trade-offs between time and space.

## Writing Better Programs
Through this project, I’ve gotten better at writing code that’s easier to read and maintain. I used comments, clear variable names, and structured my code so it’s simple to follow. I also thought about how the program could be adapted if the list of courses changed or grew larger in the future. This helped me write programs that are not only working but also adaptable.
